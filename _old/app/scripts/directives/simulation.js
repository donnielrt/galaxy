'use strict';

angular.module('galaxyApp')
    .directive('simulation', function() {
        // Since we want to modify the DOM, we create a link function
        // TODO: Is this the best way to render this?
        // TODO: Data should be generated by the controller
        function link($scope, $element) {

            // VARIABLE DECLARATIONS
            // ---------------------
            //
            // This section just declares variables, and should not contain any
            // logic

            // DOM element
            // -----------

            // The container for the <canvas> we produce
            var element = $element[0];

            // Three.js objects
            // ----------------

            var scene;
            var camera;
            var renderer;
            var light;
            var controls;

            // Scene settings
            // --------------

            var aspectRatio;

            // How much of the scene we can see, width-wise.
            var fieldOfView = 75;

            // Note: Confirm understanding of near plane and clipping plane

            // The closest object from the camera that's rendered
            var nearPlane = 0.1;
            // The farthest object from the camera that's rendered
            var clippingPlane = 1000;

            // Remember that we are 'dollying' the camera through the Z-plane,
            // not zooming in/out
            var cameraPosition = {
              x: 0,
              y: 0,
              // We can dolly out another clippingPlane/2 units, and dolly in
              // (clippingPlane/2 + clippingPlane) units
              z: clippingPlane/2
            };

            // It's obvious what this is and does. Duh. Can't believe you even
            // asked.
            var maxAniso = 1;

            // Gotta figure out how this works best. Are we just interested in
            // the element dimensions? Context dimensions?
            var width;
            var height;

            // Sun
            // ---

            // Create a 'Sun' object with properties?

            // The central star of the galaxy, equivalent to the Sun
            var sun;

            // How big the sun's gonna be
            var sRadius = 50;

            // The number of lines drawn horizontally (latitudinal lines)
            var sWidthSegments = 25; // Default 8

            // The number of lines drawn vertically (longitudinal lines)
            var sHeightSegments = 25; // Default 6

            // ...
            var sPhiStart = 0;
            var sPhiLength = Math.PI * 2;
            var sThetaStart = 0;
            var sThetaLength = Math.PI;

            // Sun's texture
            var sTexture;

            // A 'geometry' contains the points (vertices) and fill (faces) of
            // our sun
            var geometry;
            // The material the sun is built with
            var material;

            // Stars
            // -----

            var particleSystem;
            var numStars = 10000;

            // LOGIC
            // -----
            //
            // Contains the logic that runs the simulation

            // Extract the dimensions as specified in CSS (as opposed to the
            // element's width/height attributes in DOM)
            function getStyledDimensions(el){
              var styles = getComputedStyle(el);
              return {
                width: parseFloat(styles.width.replace(/px/, '')),
                height: parseFloat(styles.height.replace(/px/, ''))
              };
            }

            // Create the three.js objects we need
            function prepareScene() {
              console.log('Preparing scene');

              // The container doesn't have any width/height specified on
              // it, so we extract the CSS width/height
              var elementDimensions = getStyledDimensions(element);
              width = elementDimensions.width;
              height = elementDimensions.height;

              aspectRatio = width / height;

              scene = new THREE.Scene();

              // Why perspective camera?
              camera = new THREE.PerspectiveCamera(
                fieldOfView,
                aspectRatio,
                nearPlane,
                clippingPlane
                );

              // Does it make a difference if we set properties after creation?
              // Does it repaint/re-render?
              renderer = new THREE.WebGLRenderer();
              renderer.setSize(width, height);

              // Explicitly set a black background
              renderer.setClearColor(0x0000, 1);

              // Pan the camera out from 0, 0, 0
              camera.position.z = cameraPosition.z;

              // Controls to move the scene
              controls = new THREE.OrbitControls(camera, renderer.domElement);

              // Let Orbit know we're targeting the center (it's the default,
              // but let's be explicit). Worth trying different positions later.
              controls.target = new THREE.Vector3(0, 0, 0);

              // How far we can dolly in-out
              controls.minDistance = -1*clippingPlane;
              controls.maxDistance = clippingPlane;

              // Gets confusing with panning
              controls.noPan = true;

              // Orbit around the sun (whee!)
              controls.autoRotate = false;
              controls.rotateSpeed = 0.2;

              // Inject the element into the DOM
              element.appendChild(renderer.domElement);
            }

            // The goal is to select a star as the central 'sun' for whatever
            // galaxy we're targeting
            function generateSun() {
              console.log('Placing sun');

              // TODO: Load path from config
              sTexture = THREE.ImageUtils.loadTexture(
                // Shamelessly stolen from Chrome's 100,000 stars experiment
                // TODO: Credits page
                'images/star-surface.png',
                // Mapping to use. Default is UV mapping
                // TODO: Figure out which one is best for our purposes
                undefined,
                function() {
                  console.log('Loaded sun texture');
                }
                );

              // This does...uh...
              sTexture.anisotropy = maxAniso;

              // S? T?
              sTexture.wrapS = sTexture.wrapT = THREE.RepeatWrapping;

              // Draws vertical and horizontal segments creating a sphere
              // The angles define where the drawing starts and till where it
              // continues.
              // TODO: Is the above even correct? Do you even lift, bro?
              geometry = new THREE.SphereGeometry(
                sRadius,
                sWidthSegments,
                sHeightSegments,
                sPhiStart,
                sPhiLength,
                sThetaStart,
                sThetaLength);

              // Material the sun is made of. Everbody knows the moon is made
              // of cheese, but a little known fact is that the Sun is made of
              // MeshBasicMaterial, which is a type of milk-byproduct primarily
              // manufactured in Eastern South Korea.
              // TODO: Better material?
              material = new THREE.MeshBasicMaterial({
                // Random orangish color
                color: 0xE9C34A,
                map: sTexture
              });

              // Merge the sun with the material
              sun = new THREE.Mesh(geometry, material);
              scene.add(sun);
            }

            // TODO: Should place a point taking into account the source data,
            // i.e. the image of the galaxy, or possibly star data?
            function generateStars() {
                // Create the particle variables
                var particleCount = numStars;
                var particles = new THREE.Geometry();

                // Better material? Does it matter? Right now the particles are
                // tiny, at 1 unit. Can they be made spherical? Could they emit
                // light? Do dogs dream?
                var pMaterial = new THREE.ParticleBasicMaterial({
                  color: 0xFFFFFF,
                  size: 1
                });

                var particle;

                // Create the individual particles
                for (var p = 0; p < particleCount; p++) {

                    // create a particle with random
                    // position values the size of the current element size
                    var pX = (Math.random() * width * 3) -
                      (Math.random() * width * 3);
                    var pY = (Math.random() * height * 3) -
                      (Math.random() * height * 3);
                    var pZ = (Math.random() * clippingPlane * 3) -
                      (Math.random() * clippingPlane * 3);

                    // We reuse this in the loop since it's stored in particles
                    // We don't want those copies duplicated for no reason.
                    // Memory doesn't grow on trees.
                    particle = new THREE.Vector3(pX, pY, pZ);

                  // add it to the geometry
                  particles.vertices.push(particle);
                }

                // create the particle system
                particleSystem = new THREE.ParticleSystem(
                  particles, pMaterial);

                // Add it to the scene
                scene.add(particleSystem);
              }

            // Reset to 0, 0, 0
            // TODO: Animated reset! Sound-effects! Explosions!
            $scope.reset = function() {
              console.log("Resetting!");

              camera.position.x = cameraPosition.x;
              camera.position.y = cameraPosition.y;
              camera.position.z = cameraPosition.z;

              controls.update();
            }

            // wow. such full screen. much delight.
            // TODO: Shouldn't live here. Utilities?
            $scope.fullScreen = function() {
                var simulationElement = renderer.domElement;
                var elementDimensions;

                if (simulationElement.requestFullscreen) {
                  simulationElement.requestFullscreen();
                } else if (simulationElement.msRequestFullscreen) {
                  simulationElement.msRequestFullscreen();
                } else if (simulationElement.mozRequestFullScreen) {
                  simulationElement.mozRequestFullScreen();
                } else if (simulationElement.webkitRequestFullscreen) {
                  simulationElement.webkitRequestFullscreen();
                }

                elementDimensions = getStyledDimensions(element);

                // How do we redraw the scene to take up the entire screen?

                // Update the global width for use by other methods
                // width = elementDimensions.width;
                // height = elementDimensions.height;

                // element.width = simulationElement.width = width;
                // element.height = simulationElement.height = height;

                // renderer.setSize(width, height);
              }

            // Animation loop
            function render() {
                // raf is da bomb
                requestAnimationFrame(render);
                // Wait, why doesn't this happen in render()?
                renderer.render(scene, camera);
                // Update to account for Orbit changes to perspective
                controls.update();
            }

            // Program flow begins here
            (function init() {
              console.log('Initializing');

              // Lights, camera....
              prepareScene();

              // ...actors to their spots....
              generateSun();
              generateStars();

              console.log('Preparing to render');
              // ACTION!
              render();
            })();
          }

          return {
            link: link
          };
        });
